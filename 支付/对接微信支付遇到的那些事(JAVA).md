闲暇之余，总结一下之前做过的微信支付（h5、公众号、pc扫码）遇到的一些问题。

1、h5支付与公众号支付的异同
两者都属于手机端支付方式，h5支付为非微信浏览器支付方式，而公众号为微信浏览器支付方式（可以简单理解为在微信打开连接产生的支付）；公众号支付在调起支付前需要获取openId，并放入cookie中（微信识别用户标志，可通过view重定向获取），h5支付不需要；签名参数方面不同之处在于，微信支付的tradeType为"JSAPI"且需要openid，而h5支付tradeType为"MWEB"。

2、订单和交易流水
问题描述：不同支付方式之间转换问题，如h5产生订单后，选择公众号或者pc扫码支付产生支付异常（原因是微信唯一识别一笔交易的标志为tradeNo，而不是tradeNo+tradeType）
解决方式：考虑到订单这一属性不能记录每一笔交易的流程，因此引入交易流水概念，每调起一次支付产生一笔交易流水，且将交易流水号作为tradeNo传给微信。这样做可确保同一笔订单在不同支付方式中对应多笔交易流水（一种方式调起未支付），而微信根据交易流水不同可识别为不同的交易，弊端在于要保持订单表和交易流水表的信息一致性。需要注意的是，这种方式中退款流程也要根据交易流水号进行退款。

3、pc扫码支付codeUrl
采用页面img src请求动态获取二维码数据流，而img src获取后台传过来的二维码图片地址。好处在于在分布式系统中，采用后者会导致二维码图片地址不一致导致重复支付问题，而前者每次都是通过src动态请求获取。

4、h5支付回调页面（官方的文档也提到过这个问题）
个人理解就是支付调起完成后（不管是已支付还是未支付）页面重定向，h5支付返回view格式为："redirect:"+ mwebUrl+"&redirect_url="+redirectUrl。其中redirectUrl即上述提到重定向的页面，需要进行encode。

5、交易流水重复支付
在每次调起支付之前，根据订单号查询最近此订单最近一笔交易的流水号，并根据此流水号调用微信官方接口orderquery查询此交易状态，如状态为已支付则直接抛订单已支付异常。

6、wxNotify回调
wxNotify回调并不完全可靠，wxNotify未回调导致交易流水状态不对。可用定时任务对未支付的交易流水进行轮询，根据流水号调用官方接口orderquery查询此交易状态，如果状态为已支付则对数据做相应修改操作。（同理退款操作也可采用此种方式）

以上是我在对接微信开发遇到的问题，希望对大家有所帮助。具体实现方式可参考官方文档https://pay.weixin.qq.com/wiki/doc/api/index.html





